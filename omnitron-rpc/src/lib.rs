#![allow(clippy::type_complexity)]
#![cfg_attr(docsrs, feature(doc_cfg))]

pub use serde;
#[cfg(feature = "serde-transport")]
pub use {tokio_serde, tokio_util};

#[cfg(feature = "serde-transport")]
#[cfg_attr(docsrs, doc(cfg(feature = "serde-transport")))]
pub mod serde_transport;

pub mod trace;

pub use omnitron_rpc_macro::derive_serde;
/// The main macro that creates RPC services.
///
/// Rpc methods are specified, mirroring trait syntax:
///
/// ```
/// #[omnitron_rpc::service]
/// trait Service {
/// /// Say hello
/// async fn hello(name: String) -> String;
/// }
/// ```
///
/// Attributes can be attached to each rpc. These attributes
/// will then be attached to the generated service traits'
/// corresponding `fn`s, as well as to the client stubs' RPCs.
///
/// The following items are expanded in the enclosing module:
///
/// * `trait Service` -- defines the RPC service.
///   * `fn serve` -- turns a service impl into a request handler.
/// * `Client` -- a client stub with a fn for each RPC.
///   * `fn new_stub` -- creates a new Client stub.
pub use omnitron_rpc_macro::service;

pub(crate) mod cancellations;
pub mod client;
pub mod context;
pub mod server;
pub mod transport;
pub(crate) mod util;

use std::any::Any;
use std::error::Error;
use std::io;
use std::sync::Arc;
use std::time::Instant;

pub use crate::transport::sealed::Transport;

/// A message from a client to a server.
#[derive(Debug, serde::Serialize, serde::Deserialize)]
#[non_exhaustive]
pub enum ClientMessage<T> {
  /// A request initiated by a user. The server responds to a request by invoking a
  /// service-provided request handler.  The handler completes with a [`response`](Response), which
  /// the server sends back to the client.
  Request(Request<T>),
  /// A command to cancel an in-flight request, automatically sent by the client when a response
  /// future is dropped.
  ///
  /// When received, the server will immediately cancel the main task (top-level future) of the
  /// request handler for the associated request. Any tasks spawned by the request handler will
  /// not be canceled, because the framework layer does not
  /// know about them.
  Cancel {
    /// The trace context associates the message with a specific chain of causally-related actions,
    /// possibly orchestrated across many distributed systems.
    #[serde(default)]
    trace_context: trace::Context,
    /// The ID of the request to cancel.
    request_id: u64,
  },
}

/// A request from a client to a server.
#[derive(Clone, Copy, Debug, serde::Serialize, serde::Deserialize)]
pub struct Request<T> {
  /// Trace context, deadline, and other cross-cutting concerns.
  pub context: context::Context,
  /// Uniquely identifies the request across all requests sent over a single channel.
  pub id: u64,
  /// The request body.
  pub message: T,
}

/// Implemented by the request types generated by omnitron_rpc::service.
pub trait RequestName {
  /// The name of a request.
  fn name(&self) -> &str;
}

impl<Req> RequestName for Arc<Req>
where
  Req: RequestName,
{
  fn name(&self) -> &str {
    self.as_ref().name()
  }
}

impl<Req> RequestName for Box<Req>
where
  Req: RequestName,
{
  fn name(&self) -> &str {
    self.as_ref().name()
  }
}

/// Impls for common std types for testing.
impl RequestName for String {
  fn name(&self) -> &str {
    "string"
  }
}

impl RequestName for char {
  fn name(&self) -> &str {
    "char"
  }
}

impl RequestName for () {
  fn name(&self) -> &str {
    "unit"
  }
}

impl RequestName for i32 {
  fn name(&self) -> &str {
    "i32"
  }
}

impl RequestName for u32 {
  fn name(&self) -> &str {
    "u32"
  }
}

impl RequestName for i64 {
  fn name(&self) -> &str {
    "i64"
  }
}

impl RequestName for u64 {
  fn name(&self) -> &str {
    "u64"
  }
}

/// A response from a server to a client.
#[derive(Clone, Debug, PartialEq, Eq, Hash, serde::Serialize, serde::Deserialize)]
pub struct Response<T> {
  /// The ID of the request being responded to.
  pub request_id: u64,
  /// The response body, or an error if the request failed.
  pub message: Result<T, ServerError>,
}

/// An error indicating the server aborted the request early, e.g., due to request throttling.
#[derive(thiserror::Error, Clone, Debug, PartialEq, Eq, Hash)]
#[error("{kind:?}: {detail}")]
#[non_exhaustive]
#[derive(serde::Serialize, serde::Deserialize)]
pub struct ServerError {
  #[serde(serialize_with = "util::serde::serialize_io_error_kind_as_u32")]
  #[serde(deserialize_with = "util::serde::deserialize_io_error_kind_from_u32")]
  /// The type of error that occurred to fail the request.
  pub kind: io::ErrorKind,
  /// A message describing more detail about the error that occurred.
  pub detail: String,
}

/// Critical errors that result in a Channel disconnecting.
#[derive(thiserror::Error, Debug, PartialEq, Eq)]
pub enum ChannelError<E>
where
  E: ?Sized,
{
  /// Could not read from the transport.
  #[error("could not read from the transport")]
  Read(#[source] Arc<E>),
  /// Could not ready the transport for writes.
  #[error("could not ready the transport for writes")]
  Ready(#[source] Arc<E>),
  /// Could not write to the transport.
  #[error("could not write to the transport")]
  Write(#[source] Arc<E>),
  /// Could not flush the transport.
  #[error("could not flush the transport")]
  Flush(#[source] Arc<E>),
  /// Could not close the write end of the transport.
  #[error("could not close the write end of the transport")]
  Close(#[source] Arc<E>),
}

impl<E> Clone for ChannelError<E>
where
  E: ?Sized,
{
  fn clone(&self) -> Self {
    use ChannelError::*;
    match self {
      Read(e) => Read(e.clone()),
      Ready(e) => Ready(e.clone()),
      Write(e) => Write(e.clone()),
      Flush(e) => Flush(e.clone()),
      Close(e) => Close(e.clone()),
    }
  }
}

impl<E> ChannelError<E>
where
  E: Error + Send + Sync + 'static,
{
  /// Converts the ChannelError's source error type to a dyn Error. This is useful in type-erased
  /// contexts, for example, storing a ChannelError in a non-generic type like
  /// [`client::RpcError`].
  fn upcast_error(self) -> ChannelError<dyn Error + Send + Sync + 'static> {
    use ChannelError::*;
    match self {
      Read(e) => Read(e),
      Ready(e) => Ready(e),
      Write(e) => Write(e),
      Flush(e) => Flush(e),
      Close(e) => Close(e),
    }
  }
}

impl<E> ChannelError<E>
where
  E: Send + Sync + 'static,
{
  /// Converts the ChannelError's source error type to a dyn Any. This is useful in type-erased
  /// contexts, for example, storing a ChannelError in a non-generic type like
  /// [`client::RpcError`].
  fn upcast_any(self) -> ChannelError<dyn Any + Send + Sync + 'static> {
    use ChannelError::*;
    match self {
      Read(e) => Read(e),
      Ready(e) => Ready(e),
      Write(e) => Write(e),
      Flush(e) => Flush(e),
      Close(e) => Close(e),
    }
  }
}

impl ChannelError<dyn Any + Send + Sync + 'static> {
  /// Converts the ChannelError's source error type to a concrete type. This is useful in
  /// type-erased contexts, for example, storing a ChannelError in a non-generic type like
  /// [`Client::RpcError`].
  fn downcast<E>(self) -> Result<ChannelError<E>, Self>
  where
    E: Any + Send + Sync,
  {
    use ChannelError::*;
    match self {
      Read(e) => e.downcast::<E>().map(Read).map_err(Read),
      Ready(e) => e.downcast::<E>().map(Ready).map_err(Ready),
      Write(e) => e.downcast::<E>().map(Write).map_err(Write),
      Flush(e) => e.downcast::<E>().map(Flush).map_err(Flush),
      Close(e) => e.downcast::<E>().map(Close).map_err(Close),
    }
  }
}

impl ServerError {
  /// Returns a new server error with `kind` and `detail`.
  pub fn new(kind: io::ErrorKind, detail: String) -> ServerError {
    Self { kind, detail }
  }
}

impl<T> Request<T> {
  /// Returns the deadline for this request.
  pub fn deadline(&self) -> &Instant {
    &self.context.deadline
  }
}

#[test]
fn test_channel_any_casts() {
  use assert_matches::assert_matches;
  let any = ChannelError::Read(Arc::new("")).upcast_any();
  assert_matches!(any, ChannelError::Read(_));
  assert_matches!(any.downcast::<&'static str>(), Ok(ChannelError::Read(_)));

  let any = ChannelError::Ready(Arc::new("")).upcast_any();
  assert_matches!(any, ChannelError::Ready(_));
  assert_matches!(any.downcast::<&'static str>(), Ok(ChannelError::Ready(_)));

  let any = ChannelError::Write(Arc::new("")).upcast_any();
  assert_matches!(any, ChannelError::Write(_));
  assert_matches!(any.downcast::<&'static str>(), Ok(ChannelError::Write(_)));

  let any = ChannelError::Flush(Arc::new("")).upcast_any();
  assert_matches!(any, ChannelError::Flush(_));
  assert_matches!(any.downcast::<&'static str>(), Ok(ChannelError::Flush(_)));

  let any = ChannelError::Close(Arc::new("")).upcast_any();
  assert_matches!(any, ChannelError::Close(_));
  assert_matches!(any.downcast::<&'static str>(), Ok(ChannelError::Close(_)));
}

#[test]
fn test_channel_error_upcast() {
  use std::fmt;

  use assert_matches::assert_matches;

  #[derive(Debug)]
  struct E;
  impl fmt::Display for E {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
      write!(f, "E")
    }
  }
  impl Error for E {}
  assert_matches!(ChannelError::Read(Arc::new(E)).upcast_error(), ChannelError::Read(_));
  assert_matches!(ChannelError::Ready(Arc::new(E)).upcast_error(), ChannelError::Ready(_));
  assert_matches!(ChannelError::Write(Arc::new(E)).upcast_error(), ChannelError::Write(_));
  assert_matches!(ChannelError::Flush(Arc::new(E)).upcast_error(), ChannelError::Flush(_));
  assert_matches!(ChannelError::Close(Arc::new(E)).upcast_error(), ChannelError::Close(_));
}
